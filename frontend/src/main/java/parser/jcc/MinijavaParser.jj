/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.6";
  STATIC = false;
}
PARSER_BEGIN(JCCMinijavaParser)
package parser.jcc;

import ast.*;
import java.util.ArrayList;
import java.util.List;

public class JCCMinijavaParser {
}

PARSER_END(JCCMinijavaParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	< MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" >
|   < SINGLE_LINE_COMMENT: "//" (~["\n"])* >
|   < #NOT_STAR_SLASH: ~["*"] | "*" ~["/"] >
}

TOKEN : /* KEYWORDS */
{	
	< PRINT:		"print" >
|	< RETURN: 		"return" >
| 	< INT:			"int" >
| 	< BOOLEAN: 		"boolean" >
|   <CLASS:          "class">
|   <PUBLIC:         "public">
|   <STATIC:         "static">
|   <VOID:           "void">
|   <MAIN:           "main">
|   <STRING:         "String">
|   <EXTENDS:        "extends">
|   <IF:            "if">
|   <ELSE:          "else">
|   <WHILE:         "while">
|   <LENGTH:        "length">
|   <TRUE:          "true">
|   <FALSE:         "false">
|   <NEW:           "new">
|   <SYSTEM:        "System">
|   <OUT:           "out">
|   <PRINTLN:         "println">
|   <THIS:          "this">
}
TOKEN : /* SEPARATORS and OPERATORS*/
{	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACE: "{">
|	<RBRACE: "}">
|   <LBRACKET: "[">
|   <RBRACKET: "]">
|	<ASSIGN: "=">
|	<QUESTION:	 "?">
|	<PLUS:	 "+" >
|	<MINUS:  "-" >
|	<MULT:   "*" >
|	<SMALLER:"<">
|	<NOT:	 "!">
| 	<COLON:	 ":" >
| 	<COMMA:	"," >
| 	<SEMICOLON:	 ";" >
|   <DOT:    ".">
|   <AND:   "&&">
}
	
TOKEN :
{   < INTEGER_LITERAL: ( <DIGIT> )+ >
|   < IDENTIFIER: <LETTER> (<LETTER> | "_" | <DIGIT>)* >
|   < #LETTER: ["A" - "Z", "a" - "z"] >
|   < #DIGIT: ["0" - "9"] >
}

Program Goal() : {
	NodeList<AST> ss = new NodeList<AST>();
	Statement s;
	FunctionDecl f;
	Expression e;
}
{
	( s=Statement()
		{ ss.add(s); }
    | f=FunctionDeclaration()
		{ ss.add(f); }
	)*
	e = Expression()
	<EOF>
	{ return new Program(ss, new Print(e)); }
}

//Goal	::=	MainClass ( ClassDeclaration )* <EOF>
Program Program() : {
    MainClass main;
	NodeList<ClassDecl> classes = new NodeList<ClassDecl>();
	ClassDecl c;
}
{
    main=MainClass()
	( c=ClassDeclaration()
		{ classes.add(c); }
	)*
	<EOF>
	{ return new Program(main, classes); }
}

//TODO MainClass
//MainClass	::=	"class" Identifier "{" "public" "static" "void" "main" "(" "String" "[" "]"
//Identifier ")" "{" Statement "}" "}"
MainClass MainClass() : {
    String className;
    String argName;
    Statement s;
}
{
    <CLASS>
    className=Identifier()
    <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
        <LPAREN>
            <STRING> <LBRACKET> <RBRACKET> argName=Identifier()
        <RPAREN>
        <LBRACE> s=Statement()
        <RBRACE>
    <RBRACE>
    { return new MainClass(className,argName,s);}
}

//TODO ClassDeclaration
//ClassDeclaration	::=	"class" Identifier ( "extends" Identifier )?
//"{" ( VarDeclaration )* ( MethodDeclaration )* "}"
ClassDecl ClassDeclaration() : {
    String name;
    String superName = null;
    NodeList<VarDecl> vars = new NodeList<VarDecl>();
    NodeList<MethodDecl> methods = new NodeList<MethodDecl>();
    VarDecl v;
    MethodDecl m;
}
{
    <CLASS> name=Identifier()
    ( <EXTENDS> superName=Identifier() )?
    <LBRACE> ( v=VarDeclaration() { vars.add(v);} )*
              ( m=MethodDeclaration() {methods.add(m);} )*
    <RBRACE>
    {return new ClassDecl(name,superName, vars,methods);}
}

//TODO VarDeclaration
//VarDeclaration	::=	Type Identifier ";"
VarDecl VarDeclaration() : {
    Type t;
    String name;
}
{
    t=Type()
    name=Identifier()
    <SEMICOLON>
    {return new VarDecl(t,name,0);}
}
//TODO MethodDeclaration
//MethodDeclaration	::=	"public" Type Identifier "(" ( Type Identifier ( "," Type Identifier )* )? ")"
//"{" ( VarDeclaration )* ( Statement )* "return" Expression ";" "}"
MethodDecl MethodDeclaration() : {
    Type returnType,t;
    String name,id;
    List<VarDecl> formals;
    NodeList<VarDecl> formalsAsNodeList;
    NodeList<VarDecl> vars = new NodeList<VarDecl>();
    NodeList<Statement> statements = new NodeList<Statement>();
    Expression returnExp;
    VarDecl f;
    VarDecl v;
    Statement s;
    Type formalType;
    String formalName;
}
{
    <PUBLIC> returnType=Type() name=Identifier()
    <LPAREN> formals=FormalList()  { formalsAsNodeList = new NodeList<VarDecl>(formals);}<RPAREN> <LBRACE>
       (LOOKAHEAD(2) t=Type() id=Identifier() <SEMICOLON>
               {v = new VarDecl(t,id,0); vars.add(v);})*
               ( s=Statement() {statements.add(s);} )*
        <RETURN> returnExp=Expression() <SEMICOLON> <RBRACE>
    {return new MethodDecl(returnType,name,formalsAsNodeList,vars,statements,returnExp);}
}

FunctionDecl FunctionDeclaration() : {
	Type rt;
	String i;
	List<VarDecl> formals;
	List<Statement> stats = new ArrayList<Statement>();
	Statement s;
	Expression re;
} 
{	rt=Type() i=Identifier() "(" formals=FormalList() ")" "{" 
	    (
	    	s=Statement()					{ stats.add(s); }
	    )* 
	    "return" re=Expression() ";" 
	 "}"
	 { return new FunctionDecl(rt, i, formals, stats, re); }
}

List<VarDecl> FormalList() : {
	List<VarDecl> formals = new ArrayList<VarDecl>();
	Type t;
	String n;
}
{	( t=Type() n=Identifier() 			{ formals.add(new VarDecl(t,n, formals.size())); }
		(	
			"," t=Type() n=Identifier()	{ formals.add(new VarDecl(t,n, formals.size())); }
		)* 
	)?
	{ return formals; }
}

//Type	::=	"int" "[" "]"
//|	"boolean"
//|	"int"
//|	Identifier
Type Type() : {
	Type t;
	String name;
}
{
(
 LOOKAHEAD (2)
 "int" "[" "]"          { t =new IntArrayType(); }
|"int"					{ t = new IntegerType(); }
| "boolean"				{ t = new BooleanType(); }
| name=Identifier()     { t = new ObjectType(name);}
)						{ return t; }
}

Statement Statement() : {
	Statement s;

}
{
s=Block()       {return s;}
| s=If()        {return s;}
| s=While()        {return s;}
| LOOKAHEAD(2) s=Print()         {return s;}
| LOOKAHEAD(2) s=Assign()	{ return s; }
}

//TODO Block
Block Block() : {
	NodeList<Statement> statements = new NodeList<Statement>();
	Statement s;
}
{
<LBRACE> ( s=Statement() {statements.add(s);} )* <RBRACE> {return new Block(statements);}
}
//TODO If
If If() : {
    Statement s;
    Expression tst;
    Statement thn;
    Statement els;
}
{
    <IF> <LPAREN> tst=Expression() <RPAREN> thn=Statement() <ELSE> els=Statement()
    {return new If(tst,thn,els);}
}
//TODO While
While While() : {
    Expression tst;
    Statement body;
}
{
   <WHILE> <LPAREN> tst=Expression() <RPAREN> body=Statement()
   {return new While(tst,body);}
}
//TODO Print
Print Print() :{
    Expression exp;
}
{
    <SYSTEM> <DOT> <OUT> <DOT> <PRINTLN> <LPAREN> exp=Expression() <RPAREN> <SEMICOLON>
    {return new Print(exp);}
}
//
//ArrayAssign ArrayAssign() :{
//    String name;
//    Expression index;
//    Expression value;
//}
//{
//    name=Identifier() <LBRACKET> index=Expression() <RBRACKET> <ASSIGN> value=Expression() <SEMICOLON>
//    {return new ArrayAssign(name,index,value);}
//}

Statement Assign() : {
	String name;
	Expression value;
	Expression index;
}
{	name=Identifier() 
	( "=" value=Expression() ";"
		{return new Assign(new IdentifierExp(name), value); }
	)?
	(
     <LBRACKET> index=Expression() <RBRACKET> <ASSIGN> value=Expression() <SEMICOLON>
    {return new ArrayAssign(name,index,value);}
	)
}

//loop will start here
Expression Expression() :{
    Expression e;
    Token t;
}
{
     e=OperatorExpression() {return e;}
}

Expression ArrayExpression() : {
    Expression e;
    Expression e2;
    String i;
    Expression ie;
    NodeList<Expression> el;
}
{
    e=ObjectExpression()
     (
     <LBRACKET> e2=Expression() <RBRACKET>
    {return new ArrayLookup(e,e2);}
    )?
    (
    <DOT>
        (
        <LENGTH>
        {return new ArrayLength(e);}
        )?
        (
            i=Identifier() {ie=new IdentifierExp(i);} <LPAREN>
                el=ExpressionList() <RPAREN>
            {return new Call(e, ie, el);}
        )?
    )?
    {return e;}
}
//TODO pretty print for true/false need spaces
//TODO pretty print for Call should look different? not too sure
Expression ObjectExpression() : {
    Expression e;
    String i;
    Expression ie;
    NodeList<Expression> el;
}
{
    e=PrimaryExpression()
    (
        <DOT>
        (<LENGTH>
         {return new ArrayLength(e);}
         )?

        i=Identifier() {ie=new IdentifierExp(i);} <LPAREN>
            el=ExpressionList() <RPAREN>
        {return new Call(e, ie, el);}
    )?
    {return e;}
|   LOOKAHEAD(2) <NEW> i=Identifier() <LPAREN> <RPAREN>
    {return new NewObject(i);}
|    <NEW><INT><LBRACKET> e=Expression() <RBRACKET>
         {return new NewArray(e);}
}

//loop will ends here
Expression PrimaryExpression() : {
    Token t;
    Expression e;
    String s;
}
{
  t=<INTEGER_LITERAL>   { return new IntegerLiteral(t.image);}
| t=<TRUE>               { return new BooleanLiteral(true);}
| t=<FALSE>              { return new BooleanLiteral(false);}
| t=<THIS>               { return new This();}
| s=Identifier()          { return new IdentifierExp(s);}
| <NOT> e=Expression()   { return new Not(e);}
| <LPAREN> e=Expression() <RPAREN> {return e;} //TODO what is this one?
}

Expression OperatorExpression() :{
    Expression e;
    Expression e2;
    Token t;
}
{
    e=ArrayExpression()
    (
    (t=<AND> | t=<SMALLER> | t=<PLUS> | t=<MINUS> | t=<MULT>)
    e2=Expression()
    {   switch(t.image){
            case "&&":
                e= new And(e,e2);
                break;
            case "<":
                e= new LessThan(e,e2);
                break;
            case "+":
                e= new Plus(e,e2);
                break;
            case "-":
                e= new Minus(e,e2);
                break;
            case "*":
                e= new Times(e,e2);
                break;
            default:
                //do nothing should not get here
                break;
        }
        return e;
    }
    )?
    {
    return e;
    }
}

//Expression Expression() : {
//	Expression e, e2, e3;
//}
//{	e=CompExpression()
//	( "?" e2 = Expression()
//	  ":" e3 = Expression()
//		{	e = new Conditional(e, e2, e3); }
//	)?
//	{ return e; }
//}
//
//// For parsing anything with priority same or higher than <
//Expression CompExpression() : {
//	Expression e, e2;
//}
//{ 	e=AddExpression()
//	( "<" e2=AddExpression()
//		{ e = new LessThan(e, e2); }
//	)?
//	{ return e; }
//}
//// For parsing anything with priority same or higher than +
//Expression AddExpression() : {
//	Expression e, e2;
//	Token op;
//}
//{	e=MultExpression()
//	( 	(op="+"|op="-")
//		e2=MultExpression()
//			{ if (op.image.equals("+"))
//				e=new Plus(e, e2);
//			  else
//			  	e=new Minus(e, e2);
//			}
//	)*
//	{ return e; }
//}
//
//// For parsing anything with priority same or higher than *
//Expression MultExpression() :  {
//	Expression e, e2;
//	Token op;
//}
//{	e=NotExpression()
//	(	(op="*"|op="&&")
//	    e2=NotExpression()
//	    { if (op.image.equals("*"))
//			e = new Times(e, e2);
//         else
//            e = new And(e,e2);
//        }
//	)*
//	{ return e; }
//}
//
//// For parsing anything with priority same or higher than ! expressions:
//Expression NotExpression() : {
//	Expression e;
//}
//{ 	"!" e=NotExpression()
//		{ return new Not(e); }
//| 	e=PrimaryExpression()
//		{ return e; }
//}
//
///* PrimaryExpression is the expression that has highest precedence.*/
//Expression PrimaryExpression() : {
//	Token t;
//	String i;
//	Expression e;
//	NodeList<Expression> el;
//}
//{ t=<INTEGER_LITERAL>					{ return new IntegerLiteral(t.image); }
//| LOOKAHEAD (2)
//    e=ArrayLookup()                     {return e; }
//| e=BooleanLiteral()                    {return e; }
//| e=IdentifierExpression()              {return e; }
//| e=This()                              {return e; }
//| e=NewObject()                         {return e; }
//}
////| i=Identifier()
////	{ e = new IdentifierExp(i); }
////		( "(" el=ExpressionList() ")"
////				{ e = new Call(e, el); }
////		)?
////		{ return e; }
////TODO ArrayLookUp
//Expression ArrayLookup() : {
//    Expression e;
//    Expression array;
//    Expression index;
//}
//{
//    array=ArrayLength() <LBRACKET> index=ArrayLength() <RBRACKET>
//    {e = new ArrayLookup(array,index); return e;}
//
//}
////TODO ArrayLength
//Expression ArrayLength() :{
//    Expression e;
//    Expression array;
//}
//{
//    array=Call() "." <LENGTH>
//    {e= new ArrayLength(array); return e;}
//}
//
////TODO Call
//Expression Call() : {
//    Expression e;
//    Expression receiver;
//    Expression name;
//    NodeList<Expression> rands;
//}
//{
//    LOOKAHEAD (2)
//    receiver=NewArray() <DOT> name=IdentifierExpression()
//    <LPAREN> rands=ExpressionList() <RPAREN>
//    {e = new Call(receiver,name,rands); return e;}
//}
//
////TODO BooleanLiteral "true" "False"
//Expression BooleanLiteral() : {
//    Expression e;
//    boolean value;
//}
//{
//    <TRUE>      {value = true; e= new BooleanLiteral(value); return e;}
//    | <FALSE>   {value = false; e=new BooleanLiteral(value); return e;}
//}
//
////TODO IdentifierExp
//Expression IdentifierExpression() : {
//    Expression e;
//    String name;
//}
//{
//    name=Identifier()   {e = new IdentifierExp(name); return e;}
//}
//
////TODO "this"
//Expression This() : {
//    Expression e;
//}
//{
//    "this"  {e = new This(); return e;}
//}
//
////TODO NewArray
//Expression NewArray() : {
//    Expression e;
//    Expression size;
//}
//{
//    <NEW> <INT> <LBRACKET> size=Expression() <RBRACKET>
//    {e = new NewArray(size); return e;}
//}
//
////TODO NewObject
//Expression NewObject() : {
//    Expression e;
//    String typeName;
//}
//{
//    <NEW> typeName=Identifier() <LPAREN> <RPAREN>
//    {e= new NewObject(typeName); return e;}
//}

NodeList<Expression> ExpressionList() : {
	List<Expression> el = new ArrayList<Expression>();
	Expression e;
}
{
	( 
		e=Expression() 			{ el.add(e); }
		(
			"," e=Expression()	{ el.add(e); }
		)* 
	)?
	{ return new NodeList<Expression>(el); }
}

String Identifier() : {
	Token i;
}
{
	i = <IDENTIFIER>
	{ return i.image; }
}