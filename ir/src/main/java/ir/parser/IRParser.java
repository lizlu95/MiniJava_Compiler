/* Generated By:JavaCC: Do not edit this line. IRParser.java */
package ir.parser;

import static ir.tree.IR.*;

import util.List;
import translate.ProcFragment;
import translate.Fragments;
import translate.DataFragment;
import ir.frame.Frame;
import ir.tree.*;
import ir.temp.Temp;
import ir.temp.Label;
import ir.frame.x86_64.X86_64Frame;

@SuppressWarnings("all")
public class IRParser implements IRParserConstants {
    static private IRStm buildSEQStm(List<IRStm> s) {
        IRStm seqs = IR.NOP;
        for (IRStm stmt : s) {
            seqs = IR.SEQ(stmt, seqs);
        }
        return seqs;
    }

    final public Fragments Fragments() throws ParseException {
        ProcFragment pf;
        DataFragment df;
        Fragments f = new Fragments(null);
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MF:
                    pf = MethodFragment();
                    f.add(pf);
                    break;
                case DF:
                    df = DataFragment();
                    f.add(df);
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MF:
                case DF:
                    ;
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    break label_1;
            }
        }
        jj_consume_token(0);
        {
            if (true) return f;
        }
        throw new Error("Missing return statement in function");
    }

    final public ProcFragment MethodFragment() throws ParseException {
        Frame f;
        List<IRStm> stms;
        jj_consume_token(MF);
        jj_consume_token(LB);
        f = Frame();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case TS:
                jj_consume_token(TS);
                break;
            default:
                jj_la1[2] = jj_gen;
                ;
        }
        stms = IRStatementList();
        jj_consume_token(RB);
        {
            if (true) return new ProcFragment(f, buildSEQStm(stms));
        }
        throw new Error("Missing return statement in function");
    }

    //
//   DataFragment {
//      IRData _x 1 values
//         CONST 0
//   }
    final public DataFragment DataFragment() throws ParseException {
        List<IRExp> exps;
        Label name;
        jj_consume_token(DF);
        jj_consume_token(LB);
        jj_consume_token(IRDATA);
        name = Label();
        Integer();
        jj_consume_token(VALUES);
        exps = IRExpListNoComma();
        jj_consume_token(RB);
        {
            if (true) return new DataFragment(null, new IRData(name, exps));
        }
        throw new Error("Missing return statement in function");
    }

    final public Frame Frame() throws ParseException {
        Label labelname;
        String offset;
        List<Temp> formallist;
        jj_consume_token(FRAME);
        jj_consume_token(LB);
        jj_consume_token(label);
        jj_consume_token(EQUALS);
        labelname = Label();
        jj_consume_token(NLO);
        jj_consume_token(EQUALS);
        offset = Integer();
        jj_consume_token(formals);
        jj_consume_token(EQUALS);
        formallist = TempList();
        jj_consume_token(RB);
        {
            if (true) return new X86_64Frame(labelname, Integer.parseInt(offset), formallist);
        }
        throw new Error("Missing return statement in function");
    }

    final public List<IRStm> IRStatementList() throws ParseException {
        List<IRStm> stms = List.empty();
        IRStm s;
        jj_consume_token(LIST);
        jj_consume_token(LB);
        label_2:
        while (true) {
            s = IRStm();
            stms = stms.cons(s, stms);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LABEL:
                case MOVE:
                case CJUMPP:
                case JUMP:
                case EXP:
                    ;
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_2;
            }
        }
        jj_consume_token(RB);
        {
            if (true) return stms;
        }
        throw new Error("Missing return statement in function");
    }

    final public List<Temp> TempList() throws ParseException {
        List<Temp> stms = List.empty();
        Temp s;
        jj_consume_token(LIST);
        jj_consume_token(LB);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case REGISTER:
                case FAKEREGISTER:
                    ;
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_3;
            }
            s = Temp();
            stms = stms.cons(s, stms);
        }
        jj_consume_token(RB);
        {
            if (true) return stms.reverse();
        }
        throw new Error("Missing return statement in function");
    }

    final public List<IRExp> IRExpList() throws ParseException {
        List<IRExp> stms = List.empty();
        IRExp s;
        s = IRExp();
        stms = stms.cons(s, stms);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    break label_4;
            }
            jj_consume_token(COMMA);
            s = IRExp();
            stms = stms.cons(s, stms);
        }
        {
            if (true) return stms.reverse();
        }
        throw new Error("Missing return statement in function");
    }

    final public List<IRExp> IRExpListNoComma() throws ParseException {
        List<IRExp> stms = List.empty();
        IRExp s;
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CONST:
                case MEM:
                case NAME:
                case CALL:
                case BINOPP:
                case REGISTER:
                case FAKEREGISTER:
                    ;
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    break label_5;
            }
            s = IRExp();
            stms = stms.cons(s, stms);
        }
        {
            if (true) return stms.reverse();
        }
        throw new Error("Missing return statement in function");
    }

    final public IRExp Dest() throws ParseException {
        Temp t;
        IRExp addr;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case REGISTER:
            case FAKEREGISTER:
                t = Temp();
            {
                if (true) return IR.TEMP(t);
            }
            break;
            case MEM:
                jj_consume_token(MEM);
                jj_consume_token(LPAREN);
                addr = IRExp();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.MEM(addr);
            }
            break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public IRExp IRExp() throws ParseException {
        Temp t;
        String c;
        Label name;
        IRExp l, r;
        BINOP.Op op;
        IRExp target;
        List<IRExp> args;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case REGISTER:
            case FAKEREGISTER:
                t = Temp();
            {
                if (true) return IR.TEMP(t);
            }
            break;
            case CONST:
                jj_consume_token(CONST);
                c = Integer();
            {
                if (true) return IR.CONST(Integer.parseInt(c));
            }
            break;
            case NAME:
                jj_consume_token(NAME);
                jj_consume_token(LPAREN);
                name = Label();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.NAME(name);
            }
            break;
            case BINOPP:
                jj_consume_token(BINOPP);
                jj_consume_token(LPAREN);
                op = Op();
                jj_consume_token(COMMA);
                l = IRExp();
                jj_consume_token(COMMA);
                r = IRExp();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.BINOP(op, l, r);
            }
            break;
            case CALL:
                jj_consume_token(CALL);
                jj_consume_token(LPAREN);
                target = IRExp();
                jj_consume_token(COMMA);
                args = IRExpList();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.CALL(target, args);
            }
            break;
            case MEM:
                jj_consume_token(MEM);
                jj_consume_token(LPAREN);
                target = IRExp();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.MEM(target);
            }
            break;
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public BINOP.Op Op() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PLUS:
                jj_consume_token(PLUS);
            {
                if (true) return BINOP.Op.PLUS;
            }
            break;
            case MINUS:
                jj_consume_token(MINUS);
            {
                if (true) return BINOP.Op.MINUS;
            }
            break;
            case MUL:
                jj_consume_token(MUL);
            {
                if (true) return BINOP.Op.MUL;
            }
            break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public IRStm IRStm() throws ParseException {
        String name;
        IRExp dst, src;
        IRExp l, r;
        Label truelabel, falselabel;
        CJUMP.RelOp relop;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case MOVE:
                jj_consume_token(MOVE);
                jj_consume_token(LPAREN);
                dst = Dest();
                jj_consume_token(ASSIGN);
                src = IRExp();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.MOVE(dst, src);
            }
            break;
            case EXP:
                jj_consume_token(EXP);
                jj_consume_token(LPAREN);
                src = IRExp();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.EXP(src);
            }
            break;
            case JUMP:
                jj_consume_token(JUMP);
                jj_consume_token(LPAREN);
                l = IRExp();
                jj_consume_token(RPAREN);
                NAME n = (NAME) l;
            {
                if (true) return IR.JUMP(n.getLabel());
            }
            break;
            case CJUMPP:
                jj_consume_token(CJUMPP);
                jj_consume_token(LPAREN);
                relop = RelOp();
                jj_consume_token(COMMA);
                l = IRExp();
                jj_consume_token(COMMA);
                r = IRExp();
                jj_consume_token(COMMA);
                truelabel = Label();
                jj_consume_token(COMMA);
                falselabel = Label();
                jj_consume_token(RPAREN);
            {
                if (true) return IR.CJUMP(relop, l, r, truelabel, falselabel);
            }
            break;
            case LABEL:
                jj_consume_token(LABEL);
                truelabel = Label();
            {
                if (true) return IR.LABEL(truelabel);
            }
            break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public CJUMP.RelOp RelOp() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case E:
                jj_consume_token(E);
            {
                if (true) return CJUMP.RelOp.EQ;
            }
            break;
            case NE:
                jj_consume_token(NE);
            {
                if (true) return CJUMP.RelOp.NE;
            }
            break;
            case L:
                jj_consume_token(L);
            {
                if (true) return CJUMP.RelOp.LT;
            }
            break;
            case G:
                jj_consume_token(G);
            {
                if (true) return CJUMP.RelOp.GT;
            }
            break;
            case LE:
                jj_consume_token(LE);
            {
                if (true) return CJUMP.RelOp.LE;
            }
            break;
            case GE:
                jj_consume_token(GE);
            {
                if (true) return CJUMP.RelOp.GE;
            }
            break;
            case B:
                jj_consume_token(B);
            {
                if (true) return CJUMP.RelOp.ULT;
            }
            break;
            case BE:
                jj_consume_token(BE);
            {
                if (true) return CJUMP.RelOp.ULE;
            }
            break;
            case A:
                jj_consume_token(A);
            {
                if (true) return CJUMP.RelOp.UGT;
            }
            break;
            case AE:
                jj_consume_token(AE);
            {
                if (true) return CJUMP.RelOp.UGE;
            }
            break;
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public String Integer() throws ParseException {
        Token i;
        i = jj_consume_token(INTEGER_LITERAL);
        {
            if (true) return i.image;
        }
        throw new Error("Missing return statement in function");
    }

    final public String Id() throws ParseException {
        Token i;
        i = jj_consume_token(IDENTIFIER);
        {
            if (true) return i.image;
        }
        throw new Error("Missing return statement in function");
    }

    final public Label Label() throws ParseException {
        Token i;
        i = jj_consume_token(IDENTIFIER);
        {
            if (true) return Label.get(i.image.substring(1));
        }
        throw new Error("Missing return statement in function");
    }

    final public Temp Temp() throws ParseException {
        Token i;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case REGISTER:
                i = jj_consume_token(REGISTER);
                jj_consume_token(COLON);
                jj_consume_token(REGISTER);
            {
                if (true) return new Temp(i.image);
            }
            break;
            case FAKEREGISTER:
                i = jj_consume_token(FAKEREGISTER);
            {
                if (true) return new Temp(i.image);
            }
            break;
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * Generated Token Manager.
     */
    public IRParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[13];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x180, 0x180, 0x10000, 0xe060000, 0x0, 0x0, 0xf80000, 0x100000, 0xf80000, 0x0, 0xe060000, 0xf0000000, 0x0,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0xc0000, 0x4000, 0xc0000, 0xc0000, 0xc0000, 0x1c0, 0x0, 0x3f, 0xc0000,};
    }

    /**
     * Constructor with InputStream.
     */
    public IRParser(java.io.InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public IRParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new IRParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor.
     */
    public IRParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new IRParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor with generated Token Manager.
     */
    public IRParser(IRParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(IRParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[55];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 13; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 55; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}
